#JPA

---
객체 모델과 관계형 데이터베이스 모델의 패러다임 불일치 문제점에 대해 알아보며  
JPA를 사용할 경우 패러다임의 불일치 문제와 정교한 객체 모델링을 유지하도록 도와준다  
EJB 3.0에서 하이버네이트를 기반으로 새로운 자바 ORM 기술 표준 JPA를 만듬
---

####자바 ORM 표준 JPA 프로그래밍에서 H2 사용시
    첫 연결은 Generic H2(embedded)로 연결, 다음부터 Generic H2(Server) 연결로 진행
    Mac OS 설치법 : https://atoz-develop.tistory.com/entry/H2-Database-%EC%84%A4%EC%B9%98-%EC%84%9C%EB%B2%84-%EC%8B%A4%ED%96%89-%EC%A0%91%EC%86%8D-%EB%B0%A9%EB%B2%95

####지연로딩
    연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행
    이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 지연 로딩이라 칭함
    * 연관된 객체를 자주 사용한다면 지연 로딩이 아닌 같이 조회가 가능하도록 설정 가능하다

###영속성 컨텍스트(persistence context)

---
persistence context : 엔티티를 영구 저장하는 환경  
엔티티매니저로 엔티티를 저장하거나 조회하면 영속성 컨텍스트에 엔티티를 보관 및 관리  
엔티티매니저가 생성될 때 영속성 컨텍스트도 한개 생성  
* 서로 다른 엔티티 매니저가 같은 영속성 컨텍스트에 접근 가능  
---
####영속성 생명주기
    비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
    영속(managed) : 영속성 컨텍스트에 저장된 상태
    준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
    삭제(removed) : 삭제된 상태

####영속성 특징
    영속성 컨텍스트는 엔티티를 식별자 값(@Id)으로 구분, 영속 상태에서 식별자 값은 필수, 없으면 예외 발생
    JPA는 트랜잭션을 커밋하면 영속성 컨텍스트에 저장된 엔티티를 DB에 반영하며 flush라고 칭함
    장점 : 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지, 지연 로딩

####영속성 컨텍스트의 1차캐시
```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");
```
    이 코드를 실행하면 영속 컨텍스트의 1차 캐시에 엔티티를 저장하며 이 시점은 DB에 저장 되지않은 상태
    1차 캐시 안에 Map이 있으며 @Id와 Entity에 각 각의 데이터를 등록
    1차 캐시의 키는 식별자 값이며 식별자 값이 DB 기본 키와 매핑 되어있음
    Entity Manager의 find Method를 호출시 1차 캐시에서 엔티티를 찾고 없으면 DB에서 조회
    * 1차 캐시에 있을 경우 메모리안에 1차 캐시에서 주소값 호출하여 반환
    * DB에서 조회 해야 되는 경우 조회 후 1차 캐시에 저장 후 영속 상태의 엔티티를 반환

####동일성과 동등성
    동일성은 == 비교연산자로 메모리에 할당 된 영역이 같은지 비교하며
    동등성의 java equals()로 메모리에 할당 된 영역 안에 값이 같은지 비교한다.
    new 생성자로 JDBC Sql을 통한 데이터 조회시 메모리의 새로운 영역을 할당받기에 동일성비교는 false가 되며
    JPA를 통해 동일한 식별자로 조회 시 영속성 컨텍스트의 1차 캐시안에 있는 같은 엔티티를 반환하여 동일성 비교시 true가 되며 동일성을 보장한다

####트랜잭션을 지원하는 쓰기 지연
    엔티티 매니저, 트랜잭션을 생성하고 transaction.begin() 함수를 호출하고
    엔티티 매니저를 통해 2개의 등록 함수 persist()를 호출할 경우 엔티티 매니저는 트랜잭션을 커밋하기 직전까지
    데이터베이스에 엔티티를 저장 하지 않고 내부 쿼리 저장소에 SQL을 쌓아둔 후 transaction.commit()이 
    호출되면 모아둔 쿼리를 데이터베이스에 보내는데 이 것을 트랜잭션을 지원하는 쓰기 지연이라고 한다

####변경 감지
    JPA는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라고 칭함
    엔티티 매니저가 flush를 호출할 때 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾음
    * 테이블의 컬럼이 30개가 넘어가면 DynamicUpdate라는 하이버네이트의 확장 기술을 사용하는게 성능에 좋다고한다
    * 별도의 테스트로 성능을 확인해봐야 할 것 같다

####엔티티 삭제
    엔티티를 삭제하기 위해 먼저 삭제대상의 엔티티를 조회한 후 엔티티 매니저의 remove 호출 파라미터에 
    엔티티를 넘겨주면 삭제를 진행하는데 과정은 등록과 동일하다
    트랜잭션의 커밋까지 완료되면 영속성 컨텍스트에서 해당 엔티티는 제거된다

####플러시
    영속성 컨텍스트를 flush 하는 방법으로 flush 직접 호출, 트랜잭션 커밋 시 flush 자동 호출
    JPQL 쿼리 실행 시 flush 자동 호출 하는 3가지 방법이 있다
    flush 모드 옵션 FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시(default), FlushModeType.COMMIT : 커밋할 때만 플러시
    ex) EntityManager.setFlushMode(FlushModeType.AUTO);

####준영속
    영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 분리된 것을 준영속 상태라고 하며
    준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다
    준영속 상태로 만드는 방법으로 3가지가 있으며
    EntityManager.detach(entity) : 해당 엔티티를 준영속 상태로 전환
    EntityManager.clear() : 영속성 컨텍스트를 완전히 초기화
    EntityManager.close() : 영속성 컨텍스트 종료
    영속 컨텍스트안에서 detach 함수 호출 > 1차 캐시 제거 > 쓰기 지연 SQL 저장소 제거 (모든 제거는 해당 엔티티의 관련된 정보를 타깃한다)
    